{"version":3,"sources":["helpers/sigGen.js","helpers/Contract-Calls/rockstarCall.js"],"names":["RRbabyAbi","require","ethers","sigGenerator","uAddress","cAddress","qty","console","log","exportInstance","abi","contract","nonces","cNonce","wallet","Wallet","process","packedData","utils","solidityPack","toString","signMessage","arrayify","signature","UserSignature","uSignature","fetchInfo","addr","FetchInstance","rrBabyAbi","price","token","indicatesID","totalSupply","fetchUserBal","from","balanceOf","balance","testMint","evt","emit","parseFloat","parseInt","isActive","estimateGas","mintTokens","gasPrice","gasLimit","JSON","stringify","includes","getcateg","erc20Abi","erc20","bal","convertToEth","BigNumber","approve","MAX_ALLOWANCE_AMOUNT","txn","wait","reason","MAX_WHITELIST_BUY_PER_USER","isWhitelisted","auth","sig","whitelistedMint","whitelistMint","result"],"mappings":"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","file":"static/js/2.a28e0a41.chunk.js","sourcesContent":["import { exportInstance } from \"../apiServices\";\nconst RRbabyAbi = require(\"../config/abis/rrbaby.json\");\nconst ethers = require('ethers');\nconst privateKey = process.env.REACT_APP_PRIVATE_KEY\n\nexport const sigGenerator= async (uAddress,cAddress,qty)=>{\n    console.log(\"siggen\");\n    let contract = await exportInstance(cAddress, RRbabyAbi.abi);\n    const cNonce = await contract.nonces(uAddress);\n     const wallet = new ethers.Wallet(privateKey);     \n    const packedData = ethers.utils.solidityPack(\n        [\"address\", \"uint256\", \"uint256\"],\n        [uAddress, qty, cNonce.toString()]\n      );\n    const signature = await wallet.signMessage(\n        ethers.utils.arrayify(packedData)\n    );\n    let UserSignature = {\n        uAddress: uAddress,\n        uSignature:signature, \n    };\n    console.log(UserSignature.uSignature);\n    return UserSignature;\n} \n\n","import { MAX_ALLOWANCE_AMOUNT } from \"../constants\";\nimport erc20Abi from \"../../config/abis/erc20.json\";\nimport rrBabyAbi from \"../../config/abis/rrbaby.json\";\nimport {\n  exportInstance,\n  isWhitelisted,\n  FetchInstance,\n} from \"../../apiServices\";\nimport { convertToEth } from \"../../helpers/numberFormatter\";\nimport BigNumber from \"bignumber.js\";\nimport { sigGenerator } from \"../sigGen\";\nimport evt from \"../../events/events\";\nimport { MAX_WHITELIST_BUY_PER_USER } from \"../../helpers/constants\";\nimport { parseJSON } from \"jquery\";\n\nexport const fetchInfo = async (addr) => {\n  let contract = await FetchInstance(addr, rrBabyAbi.abi);\n  try {\n    let price = await contract.price();\n    let token = await contract.token();\n    let totalSupply = await contract.indicatesID();\n    return [price, token, totalSupply - 1];\n  } catch (e) {\n    return e;\n  }\n};\nexport const fetchUserBal = async (from, addr) => {\n  let contract = await exportInstance(addr, rrBabyAbi.abi);\n  try {\n    let balance = await contract.balanceOf(from);\n    return balance;\n  } catch (e) {\n    console.log(\"balance Error\");\n    return e;\n  }\n};\nexport const testMint = async (addr, qty, price, from) => {\n  evt.emit(\"txn-status\", \"initiate loader\");\n  price = parseFloat(price) * parseInt(qty);\n  let contract = await exportInstance(addr, rrBabyAbi.abi);\n  try {\n    let result = await contract.isActive();\n    if (result) {\n      // public mint\n      try {\n        let result = await contract.estimateGas.mintTokens(qty, {\n          from: from,\n          gasPrice: 10000000000,\n          gasLimit: 9000000,\n        });\n        if (result) {\n          return mintTokens(addr, qty, from);\n        }\n      } catch (e) {\n        if (JSON.stringify(e).includes(\"insufficient allowance\")) {\n          let getcateg = await fetchInfo(addr);\n          let erc20 = await exportInstance(getcateg[1].toString(), erc20Abi);\n          let bal = await erc20.balanceOf(from);\n          bal = convertToEth(new BigNumber(bal.toString()));\n          console.log(\"Balance of user :\", bal);\n          if (parseFloat(bal) > price) {\n            try {\n              let txn = await erc20.approve(addr, MAX_ALLOWANCE_AMOUNT, {\n                from: from,\n                gasPrice: 10000000000,\n                gasLimit: 9000000,\n              });\n              evt.emit(\"txn-status\", \"approval-initiated\");\n              txn = await txn.wait();\n              evt.emit(\"txn-status\", \"approval-succeed\");\n              if (txn) {\n                return mintTokens(addr, qty, from);\n              }\n              return [txn, true];\n            } catch (error) {\n              evt.emit(\"txn-error\", \"user-denied-approval\");\n              return [error, false];\n            }\n          } else {\n            evt.emit(\"txn-error\", \"not enough balance\");\n            return [\"not enough balance\", false];\n          }\n        }\n        if (JSON.stringify(e).includes(\"transfer amount exceeds balance\")) {\n          evt.emit(\"txn-error\", \"not enough balance\");\n          return [\"not enough balance\", false];\n        } else {\n          evt.emit(\"txn-error\", e.reason);\n        }\n      }\n      // public mint ends here\n    } else {\n      console.log(\"in whitelist\");\n      let bal = await fetchUserBal(from, addr);\n      console.log(\n        \"BALANCE IS \",\n        parseInt(bal),\n        \"and condition is :\",\n        parseInt(bal) + qty < MAX_WHITELIST_BUY_PER_USER\n      );\n      if (parseInt(bal) + qty <= MAX_WHITELIST_BUY_PER_USER) {\n        let isEligible = await isWhitelisted({\n          uAddress: from,\n          cAddress: addr,\n        });\n        if (isEligible.auth) {\n          let sig = await sigGenerator(from, addr, qty);\n          let maxQty = 2;\n\n          try {\n            let result = await contract.estimateGas.whitelistedMint(\n              qty,\n              qty,\n              sig.uSignature,\n              { from: from, gasPrice: 10000000000, gasLimit: 9000000 }\n            );\n            if (result) {\n              return whitelistMint(addr, qty, sig.uSignature, from);\n            }\n          } catch (e) {\n            if (JSON.stringify(e).includes(\"insufficient allowance\")) {\n              let getcateg = await fetchInfo(addr);\n              let erc20 = await exportInstance(\n                getcateg[1].toString(),\n                erc20Abi\n              );\n              let bal = await erc20.balanceOf(from);\n              bal = convertToEth(new BigNumber(bal.toString()));\n              console.log(\"Balance of user :\", bal);\n              if (parseFloat(bal) > price) {\n                //  let txn  = await erc20.approve(contracts.gachyiland,MAX_ALLOWANCE_AMOUNT,{from:from})\n                try {\n                  let txn = await erc20.approve(addr, MAX_ALLOWANCE_AMOUNT, {\n                    from: from,\n                    gasPrice: 10000000000,\n                    gasLimit: 9000000,\n                  });\n                  evt.emit(\"txn-status\", \"approval-initiated\");\n                  txn = await txn.wait();\n                  evt.emit(\"txn-status\", \"approval-succeed\");\n                  if (txn) {\n                    return whitelistMint(addr, qty, sig.uSignature, from);\n                  }\n                  return [txn, true];\n                } catch (error) {\n                  console.log(\n                    \"this is the response we got \",\n                    JSON.stringify(error)\n                  );\n                  if (\n                    JSON.stringify(error).includes(\n                      \"MetaMask Tx Signature: User denied transaction signature.\"\n                    )\n                  ) {\n                    evt.emit(\"txn-error\", \"user-denied-approval\");\n                    return [error, false];\n                  }\n                  if (\n                    JSON.stringify(error).includes(\n                      `\"reason\":\"repriced\",\"code\":\"TRANSACTION_REPLACED\",\"cancelled\"`\n                    )\n                  ) {\n                    let result = await testMint(addr, qty, price, from);\n                    console.log(result);\n                  }\n                }\n              } else {\n                evt.emit(\"txn-error\", \"not enough balance\");\n                return [\"not enough balance\", false];\n              }\n            }\n            if (JSON.stringify(e).includes(\"transfer amount exceeds balance\")) {\n              console.log(\"no money\");\n              evt.emit(\"txn-error\", \"not enough balance\");\n              return [\"not enough balance\", false];\n            } else {\n              evt.emit(\"txn-error\", e.reason);\n            }\n          }\n        } else {\n          evt.emit(\"txn-error\", \"address not Whitelisted\");\n          return \"address not Whitelisted\";\n        }\n      } else {\n        evt.emit(\"txn-error\", \"max nft per wallet has been reached\");\n        return \"limit has been reached \";\n      }\n    }\n  } catch (error) {\n    console.log(error);\n    evt.emit(\"txn-error\", \"txn failed\");\n    return \"TXN failed \";\n  }\n};\nconst mintTokens = async (addr, qty, from) => {\n  console.log(\"it is in minting \");\n  evt.emit(\"txn-status\", \"mint-initiated\");\n  let contract = await exportInstance(addr, rrBabyAbi.abi);\n  try {\n    let txn = await contract.mintTokens(qty, {\n      from: from,\n      gasPrice: 10000000000,\n      gasLimit: 9000000,\n    });\n    txn = await txn.wait();\n    evt.emit(\"txn-status\", \"mint-succeed\");\n    return txn;\n  } catch (e) {\n    if (\n      JSON.stringify(e).includes(\n        `reason\":\"repriced\",\"code\":\"TRANSACTION_REPLACED\",\"cancelled`\n      )\n    ) {\n      evt.emit(\"txn-error\", \"check wallet for confirmation\");\n      return e;\n    }\n    evt.emit(\"txn-error\", \"user-denied-mint\");\n    return e;\n  }\n};\nconst whitelistMint = async (addr, qty, sig, from) => {\n  console.log(\"it is in whitelisting section \");\n  evt.emit(\"txn-status\", \"mint-initiated\");\n  let contract = await exportInstance(addr, rrBabyAbi.abi);\n  try {\n    let txn = await contract.whitelistedMint(qty, qty, sig, {\n      from: from,\n      gasPrice: 10000000000,\n      gasLimit: 9000000,\n    });\n    txn = await txn.wait();\n    evt.emit(\"txn-status\", \"mint-succeed\");\n    return txn;\n  } catch (e) {\n    console.log(e);\n    if (\n      JSON.stringify(e).includes(\n        `\"reason\":\"repriced\",\"code\":\"TRANSACTION_REPLACED\",\"cancelled\"`\n      )\n    ) {\n      evt.emit(\"txn-error\", \"check wallet for confirmation\");\n      return e;\n    }\n    evt.emit(\"txn-error\", \"user-denied-mint\");\n    return e;\n  }\n};\n"],"sourceRoot":""}