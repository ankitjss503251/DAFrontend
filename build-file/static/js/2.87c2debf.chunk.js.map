{"version":3,"sources":["helpers/Contract-Calls/rockstarCall.js"],"names":["fetchInfo","addr","exportInstance","rrBabyAbi","abi","contract","price","token","indicatesID","totalSupply","testMint","qty","from","console","log","evt","emit","parseFloat","parseInt","isActive","result","estimateGas","mintTokens","value","JSON","stringify","includes","getcateg","toString","erc20Abi","erc20","balanceOf","bal","convertToEth","BigNumber","approve","MAX_ALLOWANCE_AMOUNT","txn","wait","reason","isWhitelisted","address","isEligible","auth","maxQty","whitelistedMint","signature","whitelistMint","gasPrice","gasLimit","sig"],"mappings":"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","file":"static/js/2.87c2debf.chunk.js","sourcesContent":["import { MAX_ALLOWANCE_AMOUNT } from \"../constants\";\nimport erc20Abi from \"../../config/abis/erc20.json\";\nimport rrBabyAbi from \"../../config/abis/rrbaby.json\";\nimport { exportInstance, isWhitelisted } from \"../../apiServices\";\nimport contracts from \"../../config/contracts\";\nimport { convertToEth } from \"../../helpers/numberFormatter\";\nimport BigNumber from \"bignumber.js\";\nimport evt from \"../../events/events\";\n\nexport const fetchInfo = async (addr) => {\n  let contract = await exportInstance(addr, rrBabyAbi.abi);\n  try {\n    let price = await contract.price();\n    let token = await contract.token();\n    let totalSupply = await contract.indicatesID();\n    // console.log(\"came from rockstar\",price,token,(totalSupply-1));\n    return [price, token, totalSupply - 1];\n  } catch (e) {\n    return e;\n  }\n};\n\nexport const testMint = async (addr, qty, price, from) => {\n  console.log(\"!!!!!!!!!!!!!!!!!\", addr);\n  evt.emit(\"txn-status\", \"initiate loader\");\n  price = parseFloat(price) * parseInt(qty);\n  let contract = await exportInstance(addr, rrBabyAbi.abi);\n  try {\n    let result = await contract.isActive();\n    console.log(\"result1\", result);\n    if (result) {\n           console.log(\"in minting section\");\n      // public mint\n      try {\n        console.log(\"in minting section\");\n        let result = await contract.estimateGas.mintTokens(qty, {\n          from: from,\n          value: 0,\n        });\n        console.log(\"result2\", result);\n        if (result) {\n          return mintTokens(addr, qty, from);\n        }\n      } catch (e) {\n        if (JSON.stringify(e).includes(\"insufficient allowance\")) {\n          let getcateg = await fetchInfo(addr);\n          console.log(\"cateeeegggg\", getcateg);\n          let erc20 = await exportInstance(getcateg[1].toString(), erc20Abi);\n          let bal = await erc20.balanceOf(from);\n          bal = convertToEth(new BigNumber(bal.toString()));\n          console.log(\"Balance of user :\", bal);\n          if (parseFloat(bal) > price) {\n            //  let txn  = await erc20.approve(contracts.gachyiland,MAX_ALLOWANCE_AMOUNT,{from:from})\n            try {\n              let txn = await erc20.approve(addr, MAX_ALLOWANCE_AMOUNT, {\n                from: from,\n              });\n              evt.emit(\"txn-status\", \"approval-initiated\");\n              txn = await txn.wait();\n              evt.emit(\"txn-status\", \"approval-succeed\");\n              if (txn) {\n                return mintTokens(addr, qty, from);\n              }\n              return [txn, true];\n            } catch (error) {\n              evt.emit(\"txn-error\", \"user-denied-approval\");\n              return [error, false];\n            }\n          } else {\n            evt.emit(\"txn-error\", \"not enough balance\");\n            return [\"not enough balance\", false];\n          }\n        }\n        if (JSON.stringify(e).includes(\"transfer amount exceeds balance\")) {\n          console.log(\"no money\");\n          evt.emit(\"txn-error\", \"not enough balance\");\n          return [\"not enough balance\", false];\n        } else {\n          evt.emit(\"txn-error\", e.reason);\n        }\n      }\n      // public mint ends here\n    } else {\n      let isEligible = await isWhitelisted({ address: from });\n      console.log(\"it is in whitelisting\", isEligible);\n      if (isEligible.auth) {\n        let maxQty = 2;\n\n        try {\n          let result = await contract.estimateGas.whitelistedMint(\n            qty,\n            maxQty,\n            isEligible.signature,\n            { from: from }\n          );\n          if (result) {\n            return whitelistMint(addr, qty, maxQty, isEligible.signature, from);\n          }\n        } catch (e) {\n          if (JSON.stringify(e).includes(\"insufficient allowance\")) {\n            let getcateg = await fetchInfo(addr);\n            let erc20 = await exportInstance(getcateg[1].toString(), erc20Abi);\n            let bal = await erc20.balanceOf(from);\n            bal = convertToEth(new BigNumber(bal.toString()));\n            console.log(\"Balance of user :\", bal);\n            if (parseFloat(bal) > price) {\n              //  let txn  = await erc20.approve(contracts.gachyiland,MAX_ALLOWANCE_AMOUNT,{from:from})\n              try {\n                // let txn  = await erc20.approve(addr,\"80000000000000000\",{from:from})\n                let txn = await erc20.approve(addr, MAX_ALLOWANCE_AMOUNT, {\n                  from: from,\n                  gasPrice: 10000000000,\n                  gasLimit: 9000000,\n                });\n                evt.emit(\"txn-status\", \"approval-initiated\");\n                txn = await txn.wait();\n                evt.emit(\"txn-status\", \"approval-succeed\");\n                if (txn) {\n                  return whitelistMint(\n                    addr,\n                    qty,\n                    maxQty,\n                    isEligible.signature,\n                    from\n                  );\n                }\n                return [txn, true];\n              } catch (error) {\n                evt.emit(\"txn-error\", \"user-denied-approval\");\n                return [error, false];\n              }\n            } else {\n              evt.emit(\"txn-error\", \"not enough balance\");\n              return [\"not enough balance\", false];\n            }\n          }\n          if (JSON.stringify(e).includes(\"transfer amount exceeds balance\")) {\n            console.log(\"no money\");\n            evt.emit(\"txn-error\", \"not enough balance\");\n            return [\"not enough balance\", false];\n          } else {\n            evt.emit(\"txn-error\", e.reason);\n          }\n        }\n        // public mint ends here\n      } else {\n        let isEligible = await isWhitelisted({ address: from });\n\n        if (isEligible.auth) {\n          let maxQty = 2;\n\n          try {\n            console.log(\"trying whitelist mint\", isEligible.signature);\n            let result = await contract.estimateGas.whitelistedMint(\n              qty,\n              maxQty,\n              isEligible.signature,\n              { from: from }\n            );\n\n            if (result) {\n              whitelistMint(addr, qty, maxQty, isEligible.signature, from);\n            }\n          } catch (e) {\n            console.log(\"whitelist errroorrrr\", e);\n            if (JSON.stringify(e).includes(\"insufficient allowance\")) {\n              let getcateg = await fetchInfo(addr);\n              let erc20 = await exportInstance(\n                getcateg[1].toString(),\n                erc20Abi\n              );\n              let bal = await erc20.balanceOf(from);\n              bal = convertToEth(new BigNumber(bal.toString()));\n              console.log(\"Balance of user :\", bal);\n              if (parseFloat(bal) > price) {\n                //  let txn  = await erc20.approve(contracts.gachyiland,MAX_ALLOWANCE_AMOUNT,{from:from})\n                try {\n                  let txn = await erc20.approve(addr, MAX_ALLOWANCE_AMOUNT, {\n                    from: from,\n                    gasPrice: 10000000000,\n                    gasLimit: 9000000,\n                  });\n                  evt.emit(\"txn-status\", \"approval-initiated\");\n                  txn = await txn.wait();\n                  evt.emit(\"txn-status\", \"approval-succeed\");\n                  if (txn) {\n                    return whitelistMint(\n                      addr,\n                      qty,\n                      maxQty,\n                      isEligible.signature,\n                      from\n                    );\n                  }\n                  return [txn, true];\n                } catch (error) {\n                  evt.emit(\"txn-error\", \"user-denied-approval\");\n                  return [error, false];\n                }\n              } else {\n                evt.emit(\"txn-error\", \"not enough balance\");\n                return [\"not enough balance\", false];\n              }\n            }\n            if (JSON.stringify(e).includes(\"transfer amount exceeds balance\")) {\n              console.log(\"no money\");\n              evt.emit(\"txn-error\", \"not enough balance\");\n              return [\"not enough balance\", false];\n            } else {\n              evt.emit(\"txn-error\", e.reason);\n              return e;\n            }\n          }\n        } else {\n          evt.emit(\"txn-error\", \"address not Whitelisted\");\n          return \"address not Whitelisted\";\n        }\n      }\n    }\n  } catch (error) {\n    console.log(error);\n  }\n};\nconst mintTokens = async (addr, qty, from) => {\n  console.log(\"it is in minting \");\n  evt.emit(\"txn-status\", \"mint-initiated\");\n  let contract = await exportInstance(addr, rrBabyAbi.abi);\n  try {\n    let txn = await contract.mintTokens(qty, { from: from });\n    txn = await txn.wait();\n    evt.emit(\"txn-status\", \"mint-succeed\");\n    return txn;\n  } catch (e) {\n    evt.emit(\"txn-error\", \"user-denied-mint\");\n    return e;\n  }\n};\nconst whitelistMint = async (addr, qty, maxQty, sig, from) => {\n  console.log(\"it is in whitelisting section \");\n  evt.emit(\"txn-status\", \"mint-initiated\");\n  let contract = await exportInstance(addr, rrBabyAbi.abi);\n  try {\n    let txn = await contract.whitelistedMint(qty, maxQty, sig, { from: from });\n    txn = await txn.wait();\n    evt.emit(\"txn-status\", \"mint-succeed\");\n    return txn;\n  } catch (e) {\n    evt.emit(\"txn-error\", \"user-denied-mint\");\n    return e;\n  }\n};\n"],"sourceRoot":""}